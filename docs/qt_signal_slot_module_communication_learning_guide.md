# CyberCompanion 学习长文档：Qt 信号槽、模块通信与工程基础

## 0. 先回答你刚才的问题

你的判断是对的：  
针对“项目是否用了 Qt 信号槽机制、这些模块是否通信”这个问题，**不需要改现有业务代码**。

原因很直接：

1. 代码里已经大量使用 `Signal` / `connect` / `emit`。
2. 你关心的四个模块都存在，并且有明确通信链路。
3. 当前实现属于“Qt 事件驱动 + 工作线程”的常见桌面工程写法，不是错误架构。

这份文档的目标不是让你“重写”，而是让你**看懂、讲清、可扩展**。

---

## 1. 这份文档适合你现在的阶段

你已经做过 Go、Remix、PostgreSQL 相关项目，说明你不是“零基础”。  
你现在的瓶颈更像是：

1. 概念知道名字，但不够“可执行”。
2. 跨技术栈迁移时，不能快速判断“这里该用线程？定时器？事件？还是状态机？”。
3. 能看懂局部代码，但很难把“全链路”在脑中跑通。

所以本文的结构是：

1. 先给你项目里的“真实通信图”。
2. 再补 Qt/Python 的基础语法和机制。
3. 再把你熟悉的 Go/Remix/PG 概念映射过来。
4. 最后给你可落地练习路线。

---

## 2. 你的项目里，这四类模块分别在哪里

## 2.1 事件监听模块（监测用户活动）

文件：`src/core/idle_monitor.py`  
类：`IdleMonitor(QThread)`

关键点：

1. 定义了信号：
   - `user_idle_confirmed = Signal()`
   - `user_active_detected = Signal()`
   - `idle_time_updated = Signal(int)`
   - `state_changed = Signal(str)`
2. 在线程 `run()` 里循环：
   - 读取 Windows 输入空闲时间
   - `emit` 空闲时间和状态变化

这就是“事件监听”模块本体。

## 2.2 定时器模块（定期检查）

文件：`src/core/audio_output_monitor.py`  
类：`AudioOutputMonitor(QObject)`

关键点：

1. 创建 `QTimer`：`self._timer = QTimer(self)`。
2. 周期触发：`self._timer.timeout.connect(self._poll_async)`。
3. 检测结果用信号通知外部：
   - `audio_playing_started`
   - `audio_playing_stopped`
   - `audio_state_changed`

这个模块是“定时轮询 + 信号广播”的典型组合。

## 2.3 显示模块（显示/隐藏小人）

文件：`src/ui/entity_window.py`  
类：`EntityWindow(QWidget)`

关键点：

1. 提供显示控制方法：
   - `summon(...)`
   - `enter(...)`
   - `flee()`
   - `hide_now()`
2. 内部也有多种 `QTimer` 与状态信号，用于交互和自治动画节奏。

它是 UI 执行层，不是业务决策层。

## 2.4 动画模块（播放 GIF）

文件：

1. `src/ui/gif_particle.py`
2. `src/core/gif_state_mapper.py`

角色分工：

1. `GifParticleManager` 负责“怎么播”（粒子数量、生命周期、销毁）。
2. `GifStateMapper` 负责“何时播什么”（把状态/事件映射到具体 GIF）。

---

## 3. 四个模块如何互相通信（核心）

你可以把它记成一句话：

`事件来源 -> Director 编排 -> UI/动画执行`

`Director` 在这里就是中枢。

## 3.1 用户活动监听 -> Director

在 `src/core/director.py` 的 `bind_idle_monitor` 中：

1. `idle_monitor.user_idle_confirmed.connect(self.on_user_idle)`
2. `idle_monitor.user_active_detected.connect(self.on_user_active)`
3. `idle_monitor.idle_time_updated.connect(self._on_idle_time_updated)`

也就是说，`IdleMonitor` 通过信号把事件推给 `Director`。

## 3.2 定时音频检测 -> Director

在 `src/core/director.py` 构造阶段：

1. `audio_playing_started.connect(self._on_audio_output_started)`
2. `audio_playing_stopped.connect(self._on_audio_output_stopped)`

也就是说，`AudioOutputMonitor` 的定时检查结果，变成 `Director` 的业务状态变化。

## 3.3 Director -> 显示模块

`Director` 决策之后直接调用 `EntityWindow` 方法：

1. `summon(...)`
2. `enter(...)`
3. `flee()`
4. `hide_now()`

这部分是“直接函数调用通信”，不是信号。

## 3.4 Director -> 动画模块

`Director` 会在状态/事件下调用 `GifStateMapper`：

1. `on_audio_started()`
2. `on_audio_stopped()`
3. `on_engaged()`
4. `on_fleeing()`
5. `on_hidden()`
6. `on_prolonged_idle()`

`GifStateMapper` 再调用 `GifParticleManager.spawn_particle/spawn_wave/dismiss_all`。

## 3.5 一张“工程脑图”

```text
IdleMonitor(QThread) --emit--> Director --call--> EntityWindow
AudioOutputMonitor(QTimer+Worker) --emit--> Director --call--> GifStateMapper --call--> GifParticleManager
StateMachine.state_changed --emit--> Director._on_state_changed_for_particles --call--> GifStateMapper
Tray/Voice signals --emit--> Director
```

---

## 4. Qt 信号槽机制：你必须真正理解的最小模型

如果只背一句话，请背这个：

`Signal` 是“事件广播接口”，`connect` 是“订阅关系”，`emit` 是“真正触发”。

## 4.1 最小语法

```python
from PySide6.QtCore import QObject, Signal, Slot

class Producer(QObject):
    data_ready = Signal(int)

    def work(self):
        self.data_ready.emit(42)

class Consumer(QObject):
    @Slot(int)
    def on_data_ready(self, value: int) -> None:
        print(value)

producer = Producer()
consumer = Consumer()
producer.data_ready.connect(consumer.on_data_ready)
producer.work()
```

你项目里的代码就是这个模式的大规模工程化版本。

## 4.2 为什么信号槽比“到处互相 import 调函数”更好

1. 降低耦合：事件源不用知道谁在处理。
2. 可扩展：一个信号可连接多个槽。
3. 跨线程安全语义更清晰：线程间通信用事件，而不是共享状态乱改。

## 4.3 你项目里的典型范式

范式 A：后台线程发业务事件  
`IdleMonitor.run()` -> `emit(...)` -> `Director.on_user_idle/on_user_active`

范式 B：UI动作转业务指令  
`SystemTrayManager` action `triggered.connect(...)` -> `summon_requested.emit()` -> `main.py` 连接到 `director` 方法

范式 C：状态机发状态事件  
`StateMachine.state_changed.emit(old, new)` -> `Director._on_state_changed_for_particles`

---

## 5. QTimer、QThread、Worker：为什么要混用

很多新手会问：“都用 QTimer 不行吗？”  
结论：通常不行。因为任务类型不同。

## 5.1 三类任务

1. UI协调任务（轻逻辑、要贴事件循环）
2. 阻塞 I/O（麦克风、音频 API、摄像头、网络）
3. 重 CPU 计算

对应策略：

1. UI协调 -> `QTimer` / 主线程事件循环
2. 阻塞 I/O -> `QThread` / worker 后台跑
3. 重 CPU -> 线程池或进程（按实际瓶颈决定）

## 5.2 你的项目如何落地

1. `IdleMonitor`：`QThread + while + msleep`，适合持续监测。
2. `AudioOutputMonitor`：`QTimer` 触发节拍，但真实轮询可交给 worker 线程，避免卡主线程。
3. `EntityWindow`：UI动画和交互节拍用 `QTimer/QPropertyAnimation`。

这不是“混乱”，而是工程上合理分层。

---

## 6. 同步/异步：放到你这套代码里怎么理解

## 6.1 同步（Synchronous）

当前函数调用后，要等它执行完成才继续下一行。  
例如 `Director` 里直接调用 `entity_window.enter()`，这是一种同步调用关系（调用动作是同步发生的）。

## 6.2 异步（Asynchronous）

发起动作后，结果稍后通过事件回来。  
例如：

1. `AudioOutputMonitor` 定时触发 `_poll_async`。
2. worker 线程完成检测后 `poll_finished.emit(...)`。
3. 主对象槽函数 `_on_poll_result(...)` 再处理状态。

这个是典型“请求-回调”异步链路。

## 6.3 你的项目里“同步 + 异步”并存是正常的

工程上经常是：

1. 外围事件是异步来的（用户输入、定时器、线程结果）。
2. 收到事件后，业务编排步骤本身多数是同步执行（状态判断、方法调用）。

---

## 7. 事件循环与 CPU 执行顺序（你问到的重点）

## 7.1 你可以把 Qt 主线程想成“单线程事件队列”

主线程不是“什么都并行跑”，而是：

1. 取一个事件
2. 执行对应槽函数
3. 再取下一个事件

如果某个槽函数很慢，后面的 UI 事件就会排队，用户就会感知卡顿。

## 7.2 顺序感知：不是“写在上面就先执行”，而是“谁先进入事件队列谁先处理”

比如：

1. 你点击托盘触发 `summon_requested.emit()`。
2. 同时音频检测线程也发来了 `audio_playing_started`。

两者最终都进入主线程事件处理序列，执行顺序取决于到达时机。  
所以业务代码要能容忍“事件交错”。

## 7.3 这就是为什么需要状态机

`StateMachine` 的意义就是把“允许的状态转换”写死，避免事件交错造成非法状态。

---

## 8. 状态机：把复杂事件变成可控逻辑

文件：`src/core/state_machine.py`

核心点：

1. 状态集合：`HIDDEN / PEEKING / ENGAGED / FLEEING`
2. 合法迁移表：`VALID_TRANSITIONS`
3. 迁移时：
   - 先执行旧状态退出回调
   - 更新状态
   - 执行新状态进入回调
   - `state_changed.emit(old, new)`

这等于给系统加了“交通规则”。

---

## 9. 模块通信方式总表（你可直接背下来）

在这项目里主要有三种通信方式：

1. 信号槽通信（解耦、事件驱动）
2. 直接函数调用（明确、简单、同步）
3. 共享状态 + 状态机（统一约束）

你可以这样判断一个链路：

1. 是否跨线程或跨层级广播？优先信号槽。
2. 是否是中枢内部明确控制？可直接调用。
3. 是否多事件竞争同一对象状态？必须加状态机约束。

---

## 10. Python/Qt 基础语法：只讲本项目高频点

## 10.1 类型注解

```python
def _on_idle_time_updated(self, idle_ms: int) -> None:
    ...
```

好处：

1. 可读性强，降低理解成本。
2. IDE 补全和静态检查更准确。

## 10.2 `@Slot(...)`

`@Slot` 不是必须，但推荐在 Qt 槽函数上使用，表达“这是信号处理入口”，也有助于元对象系统优化。

## 10.3 dataclass

`IdleSnapshot`、`ParticleConfig` 这种“数据容器”适合 `@dataclass`，减少模板代码，语义清晰。

## 10.4 `QObject` 生命周期

Qt 对象通常挂 parent，parent 销毁时子对象清理。  
你代码里经常 `QTimer(self)`，这是正确做法。

---

## 11. 把你熟悉的 Go / Remix / PG 概念迁移过来

## 11.1 对照 Go 的 goroutine + channel

可类比但不等价：

1. `QThread` 类似 goroutine 的“并发执行单元”。
2. Qt `Signal` 类似“事件通道”。
3. 但 Qt 有 GUI 线程约束，UI 基本必须在主线程更新。

## 11.2 对照 Remix 的组件通信

前端里你会有：

1. props 下传
2. callback 上抛
3. 全局状态管理

在这个桌面项目里可类比为：

1. `Director` 类似全局编排层。
2. `Signal` 类似事件回调上抛。
3. `EntityWindow`/`GifParticleManager` 类似具体渲染组件。

## 11.3 对照 PG 里的同步/异步与一致性

你提到“消息事件、同步异步、一致性”，可以这样迁移：

1. `Signal` = 事件通知，不等于强一致事务。
2. 状态机 = 本地一致性约束（防止非法状态）。
3. 定时轮询 + 防抖（`SILENCE_DEBOUNCE_COUNT`）= 对抖动输入做稳定化处理。

这是一种“工程一致性”，不是数据库 ACID 一致性。

## 11.4 视图水合（Hydration）怎么类比

Web hydration 是“服务端输出和客户端接管一致”。  
桌面 Qt 没有同样概念，但有近似问题：  
“状态恢复后，UI 是否与内部状态同步”。

对应实践：

1. 状态变化统一经过 `Director` 和 `StateMachine`。
2. 进入状态回调里统一刷新 UI/动画，避免散落更新导致显示不一致。

---

## 12. 你可以按这个顺序读源码（非常实用）

阅读顺序建议：

1. `src/main.py`
2. `src/core/director.py`
3. `src/core/state_machine.py`
4. `src/core/idle_monitor.py`
5. `src/core/audio_output_monitor.py`
6. `src/ui/entity_window.py`
7. `src/core/gif_state_mapper.py`
8. `src/ui/gif_particle.py`
9. `src/ui/tray_icon.py`

每读一个文件，只回答三个问题：

1. 它监听了什么事件？
2. 它发出了什么事件？
3. 它改了谁的状态？

---

## 13. 初学者最容易踩的坑（结合你项目）

## 13.1 在主线程做阻塞操作

后果：UI 卡住、动画不流畅、托盘响应慢。

## 13.2 信号连了但对象生命周期没管好

后果：回调不触发、悬挂对象、退出时清理不彻底。

## 13.3 直接在多个地方改 UI 状态，不经过中枢

后果：出现“看起来随机”的状态错乱。  
建议：让 `Director` 作为唯一编排入口。

## 13.4 无节制事件触发

后果：抖动、频繁切状态。  
你项目里做了防抖（音频停止要连续静默多次才触发），这是好实践。

---

## 14. 给你的 4 周训练计划（从“表层理解”到“能设计”）

## 第 1 周：读链路，不改功能

1. 跟踪一次 `idle -> engaged -> fleeing -> hidden` 全流程。
2. 手动画出调用图（纸上画也行）。
3. 在日志中标记每个状态切换来源。

## 第 2 周：做小改动练习

1. 给 `IdleMonitor` 增加一个 debug 信号（例如当前 idle state）。
2. 在 `Director` 里接收并记录日志。
3. 确认不影响 UI 主线程流畅性。

## 第 3 周：改一条完整业务规则

目标示例：  
“音频开始播放后，若 10 秒内用户有活动，则不触发某类粒子效果。”

你会练到：

1. 定时器逻辑
2. 状态判断
3. 信号连接点选择

## 第 4 周：重构一小块，保证行为不变

目标示例：  
把 `Director` 中某段音频分支提炼为独立私有方法，补对应测试。

你会练到：

1. 可维护性
2. 行为回归控制
3. 测试意识

---

## 15. 你现在就可以做的两个“验证型问题”

你可以自己尝试回答，并用代码验证：

问题 1：  
如果 `AudioOutputMonitor` 不可用（依赖没装），系统会不会崩？  
提示：看 `is_available`、`start()` 的降级逻辑以及 `Director` 对 monitor 是否存在的判断。

问题 2：  
为什么 `on_audio_output_stopped` 里要处理 `_audio_forced_visible`？  
提示：考虑“音频触发召唤”与“音频停止后是否自动隐藏”的一致性。

---

## 16. 一个“工程师视角”的总结

你这个项目的架构关键词不是“炫技”，而是：

1. 事件驱动
2. 状态约束
3. 线程隔离
4. 统一编排

这四件事做对了，桌面应用通常就稳了。  
你现在最需要的是：把“概念名词”升级成“看到代码就知道该怎么改、改在哪里、风险是什么”。

从你已经掌握的 Go/Remix/PG 基础看，你离这个目标已经不远了。  
下一步就是反复走“读链路 -> 小改动 -> 验证 -> 复盘”。

---

## 17. 附：与你问题直接相关的关键文件索引

1. `src/core/idle_monitor.py`
2. `src/core/audio_output_monitor.py`
3. `src/core/director.py`
4. `src/core/state_machine.py`
5. `src/ui/entity_window.py`
6. `src/core/gif_state_mapper.py`
7. `src/ui/gif_particle.py`
8. `src/ui/tray_icon.py`
9. `src/main.py`

如果你愿意，下一步我可以继续给你写一份“按函数级别的阅读导图”，把 `Director` 的关键方法按执行时序展开成一页速查表。

---

## 18. 基础概念深化总览（从“知道名词”到“能做判断”）

你后面做工程判断时，建议把知识分成三层：

1. 语法层：代码能不能写出来。
2. 机制层：代码运行时到底发生了什么。
3. 决策层：在真实约束下该选哪种实现。

很多人卡在“语法层很熟，机制层模糊”，所以一到并发或事件系统就慌。  
你现在正好是在跨这个坎。

后面这一大段我们会按机制层和决策层深入。

---

## 19. Python 基础概念深化（和 Qt 工程最相关）

## 19.1 变量不是“盒子”，是“名字绑定”

在 Python 里，变量更像“标签”。

```python
a = [1, 2]
b = a
b.append(3)
```

`a` 和 `b` 指向同一个列表对象，所以 `a` 也会变。  
这在状态管理里非常关键。

工程含义：

1. 当你把对象传给多个模块时，默认是共享引用，不是复制。
2. 若你希望隔离状态，要显式拷贝（浅拷贝/深拷贝）。
3. 对可变对象（list/dict/set）要特别注意“谁在改它”。

## 19.2 可变与不可变类型

常见不可变：

1. `int`
2. `float`
3. `str`
4. `tuple`（元素若本身可变则另说）

常见可变：

1. `list`
2. `dict`
3. `set`
4. 自定义对象实例（通常可变）

工程建议：

1. 跨线程尽量传不可变快照，少传可变共享对象。
2. 配置对象如需运行时更新，明确“读路径”和“写路径”。
3. 在关键入口做防御式复制，避免隐式联动。

## 19.3 函数是一等对象

函数可以被传递、存储、返回。  
这就是你看到 `connect(self._on_xxx)` 的原因。

```python
def handler(x):
    print(x)

callbacks = [handler]
callbacks[0](123)
```

工程含义：

1. 事件系统本质就是“保存函数引用，未来再调用”。
2. 槽函数签名要和信号参数契合。
3. 闭包 `lambda` 很方便，但会隐藏捕获变量问题。

## 19.4 闭包与 `lambda` 捕获

经典坑：

```python
funcs = []
for i in range(3):
    funcs.append(lambda: i)
```

三个函数最终都返回 `2`，因为捕获的是同一个 `i`。  
项目里 tray 菜单构建用了 `lambda cid=character_id: ...`，这是正确写法。

## 19.5 异常机制不是“报错就结束”

`try/except/finally` 是资源安全释放和降级策略核心。

你项目里的典型思路：

1. 依赖不存在时发 warning，不直接崩溃。
2. 线程里异常要捕获并发信号/日志，不可静默吞掉关键错误。
3. `finally` 里做状态复位，保证下次还能继续运行。

---

## 20. 类型注解深化（不是装饰，而是工程契约）

## 20.1 注解不会自动强制运行时类型

```python
def f(x: int) -> int:
    return x
```

Python 默认不会阻止你传字符串。  
注解主要用于：

1. IDE 提示
2. 静态检查（mypy/pyright）
3. 阅读者理解

## 20.2 `|` 联合类型和 `None`

```python
worker: QThread | None = None
```

意义是：变量可能为空。  
工程上提醒你在调用前必须判空。

## 20.3 `dataclass(slots=True)` 的价值

`slots=True` 可减少实例字典开销，并防止随手加字段。  
对于高频对象或“结构化配置对象”有好处。

## 20.4 注解的边界

注解不能替代测试。  
它告诉你“意图”，但不能保证“行为正确”。

---

## 21. Qt 对象模型深化（QObject、事件循环、线程亲和性）

## 21.1 QObject 树与父子生命周期

`QTimer(self)` 的 `self` 是 parent。  
parent 销毁时，子对象通常跟着销毁。

收益：

1. 减少手动释放错误。
2. 生命周期关系更清晰。
3. 退出时更稳定。

风险：

1. 不清楚 parent 时机会导致对象提前销毁。
2. Python 侧引用和 Qt 侧 parent 生命周期混杂时要谨慎。

## 21.2 事件循环本质

事件循环会不断：

1. 取事件
2. 分发给目标对象
3. 执行回调/槽函数

它是“合作式”的，不是抢占式。  
所以单个回调太慢，会影响其他事件响应。

## 21.3 线程亲和性（Thread Affinity）

每个 `QObject` 归属某个线程。  
归属线程负责执行该对象的事件处理逻辑。

规则简化版：

1. UI 对象应在主线程。
2. worker 对象可 `moveToThread()` 到后台线程。
3. 跨线程交互尽量走信号槽，不直接乱调用。

## 21.4 信号槽连接类型（理解级别）

Qt 底层有多种连接语义（直接调用、排队调用等）。  
你项目里常见是自动模式，跨线程时通常会走排队语义，由目标线程事件循环执行槽函数。

工程含义：

1. 跨线程信号到 UI 的更新通常是安全路径。
2. 但你仍要避免一次发太多事件造成主线程拥塞。

---

## 22. QThread 深化（为什么“继承 QThread”与“worker+moveToThread”并存）

## 22.1 两种常见模式

模式 A：继承 `QThread`，重写 `run()`。  
模式 B：`QObject` worker + `moveToThread()`。

你项目两种都有：

1. `IdleMonitor(QThread)`：简单、直观，适合单一循环任务。
2. `AudioOutputMonitor` worker：主对象 + 后台 worker 分离，职责更清晰。

## 22.2 为什么不要在 UI 线程做阻塞 I/O

阻塞 I/O 包括：

1. 麦克风录制等待
2. 摄像头读帧
3. 网络请求
4. 磁盘重操作

这些放在 UI 线程会导致界面卡住。

## 22.3 线程停止策略

常见做法：

1. 置标志位（如 `_running = False`）
2. 循环检查标志并退出
3. `wait(timeout)` 等待线程收尾

你项目里就是这个模式，属于稳妥方案。

---

## 23. QTimer 深化（定时器不是实时钟）

## 23.1 `QTimer` 的触发语义

`timeout` 只是“到了时间就把事件放入队列”。  
真正执行要看事件循环是否空闲。

这意味着：

1. 间隔 100ms 不保证每次都严格 100ms 执行。
2. 回调过慢会造成漂移与堆积。

## 23.2 单次与周期

1. `setSingleShot(True)`：触发一次。
2. 默认周期：每隔 N 毫秒触发。

工程建议：

1. 长逻辑不要放在 `timeout` 槽里。
2. 槽里最好只做“调度/触发”，耗时交后台线程。

## 23.3 轮询不是原罪

音频检测常常只能轮询（WASAPI 会话状态并非总有现成推送）。  
关键是：

1. 轮询间隔合理
2. 有防抖
3. 不阻塞主线程

你的实现具备这三点。

---

## 24. 信号风暴、抖动与防抖（Debounce/Throttle）

## 24.1 为什么会抖动

现实输入常不稳定：

1. 音频峰值忽高忽低
2. 用户输入短暂中断
3. 摄像头识别偶发失败

若每次波动都切状态，会造成闪烁和行为混乱。

## 24.2 防抖策略

你项目的一个典型例子：  
音频停止要连续静默多次才判定真正停止（`SILENCE_DEBOUNCE_COUNT`）。

这属于“时序稳定化”。

## 24.3 节流策略

节流强调“在一定时间窗内最多触发一次”。  
常用于：

1. 高频日志
2. UI提示
3. 资源重操作

---

## 25. 状态机深化（有限状态机如何抗复杂事件）

## 25.1 没有状态机时的问题

如果每个事件各自直接改 UI：

1. 事件 A 把窗口显示
2. 事件 B 同时把窗口隐藏
3. 事件 C 又开始动画

很容易出现状态冲突和不可复现 bug。

## 25.2 状态机解决的不是“功能”，是“约束”

关键价值：

1. 规定合法迁移路径
2. 统一进入/退出副作用
3. 让日志和调试有固定锚点

## 25.3 状态机 + 中枢编排是强组合

`StateMachine` 做规则，`Director` 做策略。  
一个像交通法规，一个像交警。

---

## 26. 同步与异步深化（结合 CPU 执行顺序）

## 26.1 执行顺序三层模型

1. 语言层：单线程代码按语句顺序执行。
2. 事件层：事件进入队列后按调度时机处理。
3. 线程层：多个线程并行推进，各自有局部顺序。

你看到“顺序乱了”的感觉，通常来自第 2/3 层交错，不是 Python 语法错。

## 26.2 “看起来同步，实际异步”的常见场景

`signal.emit()` 之后，槽函数未必立刻同栈执行（尤其跨线程）。  
因此不能写出依赖“emit 后立即完成某状态”的脆弱逻辑。

## 26.3 幂等性（Idempotency）非常关键

槽函数最好具备：

1. 重复触发不会造成坏状态。
2. 在边界状态下可安全 return。

例如“如果当前已是隐藏状态，再次隐藏请求应无害”。

---

## 27. 线程安全基础（你后续扩展必会遇到）

## 27.1 数据竞争

多个线程同时读写同一可变对象且无同步保护，就可能出现竞态。

防御原则：

1. 共享可变状态最小化。
2. 必须共享时用锁或消息传递。
3. UI 状态只在主线程修改。

## 27.2 锁（Lock）使用原则

锁不是越多越安全。  
目标是：

1. 临界区尽量小
2. 不在锁内做耗时 I/O
3. 避免锁嵌套导致死锁风险

你项目里 `Director` 对屏幕解读计数用锁保护，是很典型的“小临界区”实践。

## 27.3 原子性与可见性（工程直觉版）

1. 原子性：一次更新不可被中断成半状态。
2. 可见性：一个线程更新后，另一个线程何时能看到。

Qt 信号槽帮助你做“消息边界”，比共享变量直接读写更容易推理。

---

## 28. 资源生命周期与清理（桌面应用稳定性的关键）

## 28.1 启动-运行-退出三阶段

你要习惯按阶段审视资源：

1. 启动时创建哪些线程/定时器/窗口
2. 运行时何时启停
3. 退出时清理顺序是否完整

## 28.2 清理顺序建议

通常是：

1. 停止外部事件源（监听器、热键、网络）
2. 停止定时器
3. 通知线程退出并等待
4. 最后销毁 UI 对象

## 28.3 常见退出问题

1. 线程未退出导致进程挂起
2. 已销毁对象仍收到回调
3. 日志未 flush 看不到关键信息

---

## 29. 错误处理与降级（Fail-safe 思维）

## 29.1 三层错误处理

1. 本地可恢复错误：记录并继续。
2. 功能降级错误：关闭子能力，主流程继续。
3. 致命错误：明确提示并退出。

## 29.2 你的项目是“优先可运行”

例如音频依赖缺失时，模块会警告并禁用，而不是直接崩。  
这就是桌面产品常见的可用性优先策略。

## 29.3 错误信息要“可行动”

好错误信息要包含：

1. 出错模块
2. 影响范围
3. 用户或开发者下一步动作

---

## 30. 日志与可观测性（Observability）

## 30.1 没日志就没有并发调试

尤其事件驱动程序，出问题不一定能复现。  
日志就是“事后时序回放”。

## 30.2 建议日志字段

1. 时间戳
2. 线程/模块
3. 事件名
4. 状态前后值
5. 关键参数

## 30.3 低噪声日志策略

1. 高频正常路径用 `debug`
2. 关键状态切换用 `info`
3. 风险路径用 `warning`
4. 异常栈用 `exception`

---

## 31. 测试基础深化（不写测试就很难稳定迭代）

## 31.1 你最先该补的测试类型

1. 状态机迁移测试
2. 防抖逻辑测试
3. 配置开关分支测试

## 31.2 事件驱动如何测

技巧：

1. 将纯逻辑抽离成可直接调用函数。
2. 对信号触发用“观察者桩”记录事件。
3. 将时间相关逻辑参数化，避免真实等待。

## 31.3 先测“不可退化行为”

比如：

1. 非法状态迁移必须拒绝。
2. 音频抖动下不应反复开关状态。
3. 退出时线程必须回收。

---

## 32. 设计原则深化（你改代码时可当检查表）

## 32.1 单一职责

模块回答一个问题：

1. 监听模块回答“发生了什么”
2. 编排模块回答“该怎么做”
3. UI模块回答“怎么显示”

## 32.2 开闭原则（对扩展开放，对修改克制）

新增触发条件时，优先新增事件处理路径，而不是把旧逻辑大改一遍。

## 32.3 依赖方向

建议保持：

1. 业务层依赖抽象接口
2. UI层尽量不反向依赖业务细节

在你项目里，`Director` 作为中枢就承担了隔离层作用。

---

## 33. 与 Go 的深入类比（帮助你迁移思维）

## 33.1 goroutine vs QThread

共同点：

1. 都能并发执行任务。
2. 都要考虑生命周期和退出。

差异点：

1. Qt 有强 UI 线程约束。
2. 信号槽有事件循环语义，不等于裸函数调用。

## 33.2 channel vs signal

共同点：

1. 都是解耦通信手段。
2. 都适合把“事件源”和“处理者”分离。

差异点：

1. channel 是数据通道抽象，读写控制更显式。
2. signal 更偏订阅广播，和对象生命周期绑定更强。

## 33.3 context 取消 vs stop 标志

Go 常用 `context` 传取消信号。  
Qt/Python 里常见是 `_running` 标志 + `wait()` 回收。  
本质目标一致：可控退出。

---

## 34. 与 Remix/React 的深入类比（帮助你迁移组件通信思维）

## 34.1 UI 组件树 vs QObject 树

两者都强调：

1. 生命周期
2. 事件传递
3. 状态驱动渲染或行为

## 34.2 前端“状态提升” vs Director 中枢

React 里你会把共享状态提升到父组件。  
这个项目里共享行为状态提升到 `Director`。

## 34.3 副作用管理类比

React `useEffect` 管理副作用。  
Qt 里你用信号槽和定时器管理副作用触发时机。  
都要解决“何时启动、何时清理”问题。

---

## 35. 与 PostgreSQL/事件一致性的深入类比

## 35.1 数据一致性 vs 行为一致性

数据库一致性关注持久化约束。  
桌面事件系统的一致性关注“状态转移是否合法、UI是否同步”。

## 35.2 最终一致性直觉在本地事件系统中的映射

当多个异步事件同时到达时，系统可能短暂中间态。  
你需要保证最终收敛到合法状态。

## 35.3 去抖和重试可类比消息系统消费稳定化

音频检测防抖、本地重试，都类似消息系统里：

1. 抗抖动
2. 抗瞬时失败
3. 保障可恢复

---

## 36. 业务逻辑拆解模板（你以后可复用）

拿任意功能，都按这 8 个问题拆：

1. 触发源是什么？
2. 触发频率如何？
3. 是同步处理还是异步处理？
4. 处理过程中是否改共享状态？
5. 改状态是否经过状态机？
6. 失败后如何降级？
7. 退出时如何清理？
8. 哪些行为要写测试守住？

你每次改功能前先写这 8 条，bug 会少很多。

---

## 37. 你这个项目的“事件分层图”（深入版）

可以拆成四层：

1. 感知层：`IdleMonitor`、`AudioOutputMonitor`、`VoiceWakeupListener` 等。
2. 编排层：`Director` + `StateMachine`。
3. 执行层：`EntityWindow`、`GifStateMapper`、`GifParticleManager`、`AudioManager`。
4. 接入层：`main.py`、`SystemTrayManager`、设置面板。

每层只做自己职责，跨层通过事件/接口连接。  
这就是可维护性的来源。

---

## 38. 代码阅读实操（按 30 分钟一轮）

每轮流程：

1. 选一个事件（如托盘点击“立即召唤”）。
2. 从事件源查 `emit` 位置。
3. 查 `connect` 绑定到哪。
4. 跟到 `Director` 的分支逻辑。
5. 跟到 UI 执行方法。
6. 记录状态变化和定时器变化。

坚持几轮后，你会形成“动态阅读能力”。

---

## 39. 改动前风险评估模板（新手非常推荐）

改任何逻辑前，先写四行：

1. 影响哪些信号源？
2. 影响哪些状态迁移？
3. 影响哪些定时器或线程？
4. 如何回归验证？

这四行写不清，先别改。

---

## 40. 常见反模式（看见就要警惕）

1. 在多个模块直接改同一 UI 状态，不经过编排层。
2. 在槽函数里做长时间阻塞。
3. 线程退出无等待，靠进程退出“硬结束”。
4. 错误处理只 `print` 不分级别。
5. 新增状态却不更新迁移表。
6. 新增事件却没有测试覆盖临界分支。

---

## 41. 如何把“基础语法”变成“工程能力”

给你一个简单但有效的升级路径：

1. 语法阶段：能写类、函数、异常、注解。
2. 机制阶段：能解释事件循环、线程亲和、信号时序。
3. 设计阶段：能说明为什么选 QTimer 或 QThread。
4. 工程阶段：能加功能且不引入状态混乱。
5. 产品阶段：能在约束下做稳定与体验权衡。

你现在已经在 2 和 3 之间，目标是稳定推进到 4。

---

## 42. 你可以立刻做的深化练习（附预期收获）

练习 A：给 `IdleMonitor` 增加“状态变化计数器”并上报。  
收获：熟悉信号扩展与低侵入改动。

练习 B：给音频检测增加“最近一次匹配会话摘要”展示。  
收获：理解防抖后的状态解释能力。

练习 C：在 `Director` 增加一条“调试状态快照”方法。  
收获：学会可观测性设计。

练习 D：为状态机非法迁移写测试。  
收获：把架构约束转成自动化守护。

---

## 43. 术语速查（深化版）

1. 事件驱动：由事件触发执行，而非固定流程串行到底。
2. 信号槽：发布-订阅式回调绑定机制。
3. 线程亲和：对象归属于某线程并在其事件循环处理事件。
4. 防抖：需连续满足条件才触发，抗短时抖动。
5. 节流：时间窗内限制触发频率。
6. 幂等：重复执行结果一致且无副作用放大。
7. 状态机：用状态和迁移规则约束系统行为。
8. 可观测性：通过日志/指标还原运行过程的能力。
9. 降级：在部分能力失败时维持核心功能可用。
10. 生命周期：对象从创建到销毁的完整过程。

---

## 44. 一份“写代码前 60 秒自检清单”

1. 这个改动是事件源改动、编排改动，还是 UI 执行改动？
2. 有没有跨线程访问共享可变状态？
3. 是否会导致信号频率大幅上升？
4. 是否需要防抖/节流？
5. 是否影响状态机合法迁移？
6. 退出路径是否仍能完整清理？
7. 有没有至少一个能覆盖风险点的测试？

---

## 45. 最后给你的学习建议（面向你现在的背景）

你已经有 Go/Remix/PG 经验，建议不要再走“背定义”的路线，改走“机制对照 + 项目验证”路线：

1. 每学一个概念，都在本项目找真实位置。
2. 每次改动先写风险清单，再动手。
3. 每次修 bug 后补一条“如何早发现”日志或测试。

坚持几轮后，你会明显感觉从“会写”变成“会设计、会维护”。
