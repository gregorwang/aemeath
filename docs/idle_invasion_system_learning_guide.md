# Idle Invasion 系统学习文档（从表层到可独立设计）

> 目标读者：你这种“做过 Go / Remix 项目，概念知道但还没吃透”的开发者。  
> 目标：把这次 `Idle Invasion` 功能，变成你理解事件驱动系统、同步/异步、一致性、性能工程的一个完整样本。

---

## 1. 先建立全局图：这次功能到底是什么

一句话：  
`Idle Invasion` 是一个基于空闲时间的、事件驱动的“多实体调度系统”。

它不是“播一个动画”，而是一个小型运行时：

1. 输入层：监听用户空闲时长与活动恢复。
2. 调度层：决定何时开始、何时加速、何时停止、何时退场。
3. 资源层：控制最多多少个实体，避免无限增长。
4. 渲染层：每个实体是一个透明 GIF 窗口，带入场/退场动画。

在代码里，对应大致是：

- `src/core/idle_monitor.py`：输入事件（空闲/恢复/空闲时长）
- `src/core/idle_invasion.py`：核心调度与状态机
- `src/ui/gif_particle.py`：单个粒子的窗口与动画
- `src/core/config_manager.py` + `config.json`：可配置运行参数
- `src/core/director.py` + `src/main.py`：系统接线与生命周期

---

## 2. 和你熟悉的 Go / Remix 概念做映射

你已经懂很多“表层”词，这里把它们落到这套系统：

### 2.1 同步 / 异步

- 同步：函数调用立刻执行并返回（比如计算下一个生成间隔）。
- 异步：事件到了才执行回调（比如 `idle_time_updated` 信号触发）。

类比：

- Go 里：`go func(){}` + channel + select
- Remix 里：loader/action + 浏览器事件循环
- Qt 里：Signal/Slot + Event Loop + QTimer

结论：  
这个项目的“异步核心”不是 `async/await`，而是 Qt 事件循环。

### 2.2 事件消息

`IdleMonitor` 相当于“事件源”，持续发：

- `idle_time_updated(int)`
- `user_idle_confirmed()`
- `user_active_detected()`

`IdleInvasionController` 作为“消费者”，根据事件更新状态机并调度下一步。

### 2.3 一致性

这里没有数据库事务，但有“运行时状态一致性”：

- 不能在 `RETREATING` 状态继续生成。
- 已占用网格不能再分配，避免重叠。
- 用户恢复活动后必须最终收敛到 `INACTIVE`。

这就是应用内的一致性约束。

### 2.4 CPU 执行顺序

你关心“CPU 执行顺序”，这在事件系统里要分两层看：

1. 单次回调内部：是普通顺序执行。
2. 回调之间：由事件循环按到达时间和队列调度顺序执行。

这也是为什么“状态机护栏”比“猜执行顺序”更可靠。

### 2.5 组件通信

Remix 常见是 props/context/store；Go 常见 channel/RPC；Qt 是 signal-slot。

本项目通信链：

`IdleMonitor -> IdleInvasionController -> GifParticle`

---

## 3. 这次代码里最值得你吃透的 5 个基础语法点（Python）

### 3.1 `dataclass`

配置结构用 `@dataclass`，可读、可序列化、便于默认值管理。  
对应：`src/core/config_manager.py` 里的 `IdleInvasionConfig`。

### 3.2 类型标注

例如：

- `dict[int, GifParticle]`
- `set[tuple[int, int]]`
- `tuple[str, ...]`

类型标注意义：

1. 约束心智模型；
2. IDE 提示更强；
3. 单测和重构更稳。

### 3.3 `Enum` 状态机

`InvasionState` 用 `Enum`，避免魔法字符串。

### 3.4 `QTimer` + 回调

`QTimer.singleShot(...)` / `QTimer.timeout.connect(...)` 是节拍驱动核心。

### 3.5 信号槽（`@Slot`）

`@Slot(int)` 明确槽函数签名，提高可维护性与工具支持。

---

## 4. 业务逻辑拆解：Idle Invasion 的状态机

当前状态：

- `INACTIVE`：未开始
- `SPAWNING`：持续生成
- `SATURATED`：达到上限或无空格
- `RETREATING`：退场中

核心转移（简化）：

1. `INACTIVE --(空闲达到 start_delay)--> SPAWNING`
2. `SPAWNING --(满员/满格)--> SATURATED`
3. `SPAWNING/SATURATED --(用户恢复活动)--> RETREATING`
4. `RETREATING --(全部粒子结束)--> INACTIVE`

这套图很像你在后端做的有限状态流程，只是这里对象是“UI 粒子”。

---

## 5. 不重叠是怎么做到的（网格占位法）

关键思想：

1. 把屏幕切成网格。
2. 每次从“未占用格子”随机选一个。
3. 生成后把格子标记为占用。
4. 退场后释放格子。

复杂度直觉：

- 判空位：接近 O(1) / O(n) 之间（取决于实现分支）。
- 不做复杂碰撞检测，逻辑更稳定。

你可以把它想成“座位分配系统”，而不是“物理碰撞系统”。

---

## 6. 为什么会占性能：不是 Python 慢，是渲染代价高

你问得很关键。瓶颈主要不在“语言”，在“模型”：

1. 每个小人是一个顶层透明窗口（系统合成器要逐层处理）。
2. 每个窗口跑一个 GIF 解码器（`QMovie`）。
3. 多个动画同时刷新会增加 CPU/GPU 合成压力。

所以性能开销来自：

- 窗口数量
- GIF 分辨率/帧数
- 动画并发数
- 透明合成

当前为什么更稳：

1. 有 `max_invaders` 上限；
2. 渐进生成，不会瞬时爆量；
3. 退场与 shutdown 清理路径完整；
4. 网格约束减少无效重叠。

---

## 7. 你熟悉的“数据一致性”在这里怎么用

虽然没有 PG 事务，但你可以套同样思维：

### 7.1 不变量（Invariant）

举例：

1. 一个格子最多一个粒子。
2. `RETREATING` 时不允许新增粒子。
3. `INACTIVE` 时不应残留粒子。

这和数据库里的约束思想一样。

### 7.2 最终一致性

用户活动恢复后，不要求 0ms 全灭，但要求“最终回到 INACTIVE 且清空粒子”。  
这就是应用层 eventual consistency。

---

## 8. 同步 / 异步“易错点”与规避方式

### 8.1 易错点

1. 同一个事件被重复触发导致重复启动。
2. 退场时仍有定时器继续生成。
3. 配置热更新后新旧参数混杂。

### 8.2 规避方式（你这次代码已经在做）

1. 状态机分支早返回（guard clauses）。
2. 切状态时立刻 `stop()` 不该继续的 timer。
3. `apply_config` 后重建关键缓存/约束。

---

## 9. Phase 2 / 3 / 4 到底分别在“工程上”意味着什么

### 9.1 Phase 2（已做）

- 渐进加速节奏（分段区间）
- 多种退场策略（`scatter/ripple/instant`）

价值：体验更像“入侵系统”，不是机械定时器。

### 9.2 Phase 3（已做）

- Settings UI 可编辑所有关键参数

价值：从“改 JSON”升级为“运行时可调优”。

### 9.3 Phase 4（未重构）

- 单窗口精灵渲染 / 更激进的共享解码

价值：高并发下潜在性能收益大；  
代价：渲染架构重写，回归面大。

所以 Phase 4 不是“危险”，是“高收益高风险”。

---

## 10. 你可以直接照着做的学习路线（建议 2 周）

### 第 1 阶段（2-3 天）：读懂执行流

1. 从 `src/main.py` 看对象构建与绑定。
2. 看 `IdleMonitor` 信号何时发出。
3. 看 `IdleInvasionController` 收信号后如何切状态。

输出目标：你能画出一张时序图。

### 第 2 阶段（3-4 天）：自己改一个策略

建议任务：

1. 新增一种退场策略（例如 `column_wave`）。
2. 给它加配置解析与 UI 选项。
3. 写至少 2 个单测。

输出目标：完整改动链（配置->逻辑->UI->测试）。

### 第 3 阶段（3-4 天）：做性能观测

建议任务：

1. 每 10 秒打印一次 invader 数量和进程内存。
2. 在 `max_invaders=20/40/60` 做对比记录。

输出目标：得到你自己机器上的容量曲线，而不是猜测。

### 第 4 阶段（3-5 天）：尝试 Phase 4-lite

建议任务：

1. 先做“同 GIF 共享解码缓存池”，不改渲染模型。
2. 对比改动前后内存峰值。

输出目标：学会“先做低风险优化，再决定大重构”。

---

## 11. 给你的“概念翻译表”（Go / Remix / 桌面 Qt）

| 你熟悉的词 | 在这个项目里对应 |
|---|---|
| goroutine | Qt 线程 + 事件循环回调 |
| channel 事件 | Signal/Slot |
| 请求生命周期 | 状态机生命周期 |
| 最终一致性 | 退场后最终收敛到 INACTIVE |
| 组件通信 | Monitor -> Controller -> Particle |
| 水合(Hydration) | 桌面中更像“状态注入+组件激活”，不是 SSR hydration |
| 背压/限流 | `max_invaders` + 定时节流 |

---

## 12. 你现在应该形成的“工程直觉”

1. UI 动画系统本质是一个实时调度系统，不是纯前端样式问题。  
2. 同步/异步不是语法问题，是“谁驱动谁、何时执行”的建模问题。  
3. 一致性不是数据库专属，运行时状态同样需要约束。  
4. 性能优化先做观测，再做低风险改动，最后才做架构重写。  
5. 单测不是“锦上添花”，而是防止回归的最低成本保险。

---

## 13. 下一步学习任务（可直接开工）

1. 给 `IdleInvasion` 加“运行时指标日志”并在托盘展示最近一次峰值。  
2. 把 `participating_gifs` 做成设置面板可选择文件（而不只是文本输入）。  
3. 写一份你自己的“状态机不变量清单”，并在关键转移处加断言/日志。  
4. 设计 `Phase 4-lite` 技术方案：目标、风险、回滚策略、验证指标。

---

如果你愿意，下一步我可以再给你写一份“逐行读代码练习册”，按文件顺序给你 30 个小问题，做完你会明显从“懂概念”变成“能独立做功能”。

---

## 14. 深入事件循环：为什么“没有 while true 也能持续工作”

很多新手会问：  
“我没写循环，为什么系统一直在响应事件？”

答案：Qt 帮你维护了一个全局事件循环（event loop），`app.exec()` 启动后：

1. 事件源不断把事件塞进队列（鼠标、键盘、定时器、窗口消息、信号回调）。
2. 事件循环不断取出事件并分发给目标对象。
3. 你的槽函数（slot）只是事件触发后的业务代码。

在本项目里：

- `IdleMonitor` 线程里每 100ms 采样并发射 `idle_time_updated`。
- 主线程收信号后进入 `IdleInvasionController._on_idle_time_updated`。
- `QTimer` 超时事件再触发 `_on_spawn_tick` 或退场流程。

你可以把它理解为：

- Go：runtime scheduler + goroutine 任务切换。
- Node/Remix：event loop + callback queue。
- Qt：native message loop + Qt event queue + signal/slot bridge。

关键工程结论：  
“异步系统设计”首先是“事件来源、队列、处理顺序”设计，而不是语法糖设计。

---

## 15. Qt 线程模型：线程安全和“看起来像并发，其实是串行队列”

### 15.1 当前线程分工

- `IdleMonitor`：`QThread`（采样系统空闲时间）
- UI 主线程：窗口创建、动画、渲染、Controller 逻辑

### 15.2 为什么没有明显数据竞争

你现在的控制器字段（如 `_particles`, `_occupied`）基本在 UI 线程读写。  
`IdleMonitor` 发信号到控制器时，Qt 会做跨线程投递（queued connection），最终在接收方线程执行槽函数。

这让你避免了很多“显式锁”复杂度，但也要注意：

1. 槽函数不要阻塞太久，否则 UI 卡顿。
2. 跨线程信号不代表“立刻执行”，它是入队后再执行。

---

## 16. 可重入（Reentrancy）与状态机护栏

可重入问题常见于：

1. 一个函数执行中又被事件触发再次进入。
2. 两个事件很接近，顺序可能与你直觉不同。

你当前做得对的地方：

- 通过状态机判定（如 `RETREATING` 时禁止生成）做“护栏”。
- 通过 `timer.stop()` 明确终止旧节拍。

建议你记住一个万能规则：

1. 先判断“当前状态是否允许本次操作”。
2. 不允许就立即 return（guard clause）。
3. 允许才继续执行业务逻辑。

这和后端幂等处理、事务前置检查是同一个思路。

---

## 17. 幂等（Idempotency）：同一事件重复到达也不能炸

幂等的定义：重复执行 N 次，结果与执行 1 次一致（或可接受）。

在 UI 系统里也非常重要。例如：

- 用户连续抖动鼠标，`user_active_detected` 可能频繁触发。
- 若退场逻辑不是幂等，可能出现重复清理、状态错乱、异常日志爆炸。

你可以检查每个关键动作是否幂等：

1. `_begin_retreat()` 被调用两次是否安全？
2. `_dismiss_all_immediate()` 对已销毁粒子是否安全？
3. `shutdown()` 多次调用是否安全？

如果都安全，系统抗抖动能力就会明显提升。

---

## 18. 时间语义：Wall Clock vs Monotonic 时间

你在后端可能听过：

- Wall Clock（系统时间，可能被用户调整）
- Monotonic（单调递增，适合计时）

空闲时间来自 Windows API tick，本质更接近单调计时，适合做“持续时长判定”。  
这比直接用 `datetime.now()` 更稳，因为系统改时间不会破坏逻辑。

工程经验：

1. “比较持续时长”用 monotonic。
2. “展示给用户的时间戳”用 wall clock。

---

## 19. 背压（Backpressure）在桌面端的实际形式

背压不是后端专属。  
你的桌面动画系统同样要处理“生产速度 > 消费能力”。

这里的生产者是：

- 空闲事件触发 + 生成计时器

消费者是：

- 窗口系统 / GPU 合成 / GIF 解码能力

背压手段：

1. 数量背压：`max_invaders`
2. 速率背压：spawn interval（且按阶段控制）
3. 资源背压：粒子大小、GIF 列表、退场策略

如果没有这些，系统会像无队列限流的消息系统一样“雪崩”。

---

## 20. 一致性分层：你可以这样想

把“一致性”拆三层会更清楚：

### 20.1 状态一致性（State Consistency）

- 状态机转移合法
- 不出现“INACTIVE 但还有粒子”

### 20.2 空间一致性（Spatial Consistency）

- 同一网格不能分配给两个粒子
- 粒子位置不能越界

### 20.3 生命周期一致性（Lifecycle Consistency）

- 启动、运行、退场、关闭必须形成闭环
- `shutdown` 时资源必须最终释放

这三层分别对应后端里的：

- 状态流约束
- 数据完整性约束
- 资源生命周期管理

---

## 21. 为什么 GIF 比你想的更“贵”

### 21.1 内存估算模型（粗略）

假设单帧 RGBA：

`bytes = width * height * 4`

如果 GIF 有 `N` 帧，且启用全帧缓存（`CacheAll`），理论缓存量接近：

`width * height * 4 * N`

再乘以实例数，就是总量级。  
这也是“同一 GIF 被多实例使用”时内存会快速上升的根因。

### 21.2 CPU/GPU 开销点

1. GIF 帧切换解码
2. 多顶层透明窗口合成
3. 入场/退场动画位置更新

这也是为什么你会看到：

- 少量对象很流畅
- 到某个数量后突然掉帧

---

## 22. 观察性（Observability）：从“感觉卡”到“数据说话”

建议把指标分 4 类：

1. 流量指标：当前粒子数、每分钟生成数、退场耗时。
2. 资源指标：进程 RSS、CPU%、GPU 占用（可选）。
3. 稳定性指标：异常次数、强制清理次数（retreat timeout fallback）。
4. 用户体验指标：平均首个入侵延迟、平均退场完成时间。

最小可行实现：

1. 每 10 秒打印一次：
   - `state`
   - `active_count`
   - 内存（MB）
2. 每次 `SATURATED` 和 `RETREATING->INACTIVE` 打关键日志。

没有可观测性，你永远是在“猜性能”。

---

## 23. 测试策略：异步 UI 系统怎么测

### 23.1 单元测试（你现在已有）

适合测：

- 间隔计算函数
- 配置解析边界值
- 状态流分支逻辑

### 23.2 组件级测试（建议补）

适合测：

- 控制器 + 假定时器
- 控制器 + 假粒子对象

### 23.3 压力/浸泡测试（建议加脚本）

适合测：

- 30 分钟持续空闲模拟
- 多轮“空闲->激活->空闲”循环

目标不是 100% 覆盖率，而是覆盖高风险路径。

---

## 24. 确定性测试技巧（让异步逻辑可测）

异步最难是“随机 + 时钟 + 事件顺序”。

常见做法：

1. 注入随机数源（可固定 seed）。
2. 把 `now()` 或 idle 值抽象成可控输入。
3. 用假计时器替代真实 `QTimer`（或在测试里 monkeypatch）。

你已经在间隔测试里用 `patch(random.randint)`，这是正确方向。

---

## 25. 配置演进：向后兼容思维

你在 `ConfigManager` 做了很好的防御式解析：

1. 非法值 clamp 到安全范围。
2. 未知 `retreat_style` 回退到默认值。
3. 缺字段使用默认配置。

这就是“配置 schema 演进”的核心。  
你可以把它当成“弱事务 + 容错反序列化”。

建议再进一步：

1. 给配置加 `schema_version`。
2. 写 migration 函数（v1->v2->v3）。
3. 在日志中记录“发生了哪些自动纠正”。

---

## 26. 设计权衡：为什么先做 Phase 4-lite

完整 Phase 4（单窗口精灵系统）收益大，但成本也大：

1. 窗口模型变化（多个顶层窗口 -> 一个全屏透明窗口）
2. 动画时序需要重写
3. 点击穿透、Z-order、多屏逻辑都要重验

Phase 4-lite（先做共享解码池）是更稳路线：

1. 渲染接口不变
2. 资源占用可明显下降
3. 回滚成本低

这就是经典“先做低耦合高收益优化”。

---

## 27. 失效模式（Failure Modes）清单

你做系统设计时，建议先写失效模式：

1. 无有效 GIF 路径：系统应不崩溃且可恢复。
2. 主屏不可用：应降级并记录日志。
3. 粒子退场回调未触发：超时强制清理。
4. 配置热更新为极端值：应被 clamp。
5. 退出过程被中断：再次启动不应残留状态污染。

把这些列成 checklist，质量会比“写完再测”高很多。

---

## 28. 你提到的“同步异步一致性”在本项目的完整案例

给你一条完整链路（非常重要）：

1. `IdleMonitor` 异步产生事件（idle_ms）。
2. `IdleInvasionController` 同步处理当前事件并更新本地状态。
3. `QTimer` 未来某个时刻异步触发下一次生成。
4. 用户活动异步中断流程，进入退场。
5. 退场完成后同步收敛状态到 `INACTIVE`。

这就是：

- 异步事件流 + 同步状态变更 + 最终一致性收敛

你把这条链彻底吃透，后续做消息系统、任务系统、前端状态系统都会轻松很多。

---

## 29. 面向业务逻辑的“七问法”（你每做一个功能都可套用）

1. 触发源是什么？（谁发事件）
2. 核心状态有哪些？（状态机）
3. 不变量是什么？（一致性）
4. 峰值负载是多少？（容量）
5. 限流/背压在哪里？（保护）
6. 失败时怎么收敛？（降级与恢复）
7. 如何验证？（测试与指标）

把这七问写在每个 PR 描述里，你的工程成熟度会快速提升。

---

## 30. 从“会改代码”到“会做系统”的里程碑

你可以用下面标准自测：

### 初级

1. 能读懂现有逻辑并改一个参数。
2. 能补一个小 bug。

### 中级

1. 能新增一个策略并配套配置/UI/测试。
2. 能解释为什么这样设计（不是只会写）。

### 高级

1. 能提出可量化优化目标与指标。
2. 能做低风险演进方案和回滚方案。

你现在已经在“初级到中级”的门槛上了，差的是系统化练习，不是智力。

---

## 31. 练习题（建议你亲手做）

### 练习 A：幂等性

任务：

1. 连续快速调用 20 次 `_begin_retreat()`。
2. 验证不会异常，最终状态回到 `INACTIVE`。

### 练习 B：背压

任务：

1. 把 `max_invaders` 分别设为 10/30/50。
2. 记录 10 分钟内内存峰值和流畅度主观评分。
3. 输出你的“默认值推荐”。

### 练习 C：一致性

任务：

1. 在关键状态转移处加断言日志。
2. 故意制造异常路径（例如无 GIF）。
3. 验证系统仍可恢复。

### 练习 D：演进设计

任务：

1. 写一页 `Phase 4-lite` 设计：
   - 目标
   - 方案
   - 风险
   - 验证
   - 回滚

---

## 32. 推荐阅读顺序（结合你现在项目）

1. `src/core/idle_monitor.py`
2. `src/core/idle_invasion.py`
3. `src/ui/gif_particle.py`
4. `src/core/config_manager.py`
5. `src/ui/settings_dialog.py`
6. `tests/test_idle_invasion_intervals.py`

每读完一个文件，回答两个问题：

1. 这个模块“输入是什么、输出是什么”？
2. 这个模块“最怕什么异常输入”？

---

## 33. 结语：你现在最该练的不是语法，是建模

你已经有 Go / Remix 的项目经验，这很宝贵。  
下一步突破点不是“再记几个关键字”，而是把“系统建模能力”练出来：

1. 事件建模（谁触发谁）
2. 状态建模（现在处于什么阶段）
3. 约束建模（哪些事情绝不能发生）
4. 成本建模（CPU/内存/复杂度）

当你能稳定回答这四类问题，你就不再是“会写代码的人”，而是“能做系统的人”。

---

如果你愿意，我下一份会给你做一版《Idle Invasion 源码逐行练习册（50 题）》，题目会覆盖：  
状态机、异步事件、定时器、配置演进、性能优化、测试设计，并附参考答案。
